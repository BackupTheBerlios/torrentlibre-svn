/*******************************************************
** Copyright (C) 2006 Francois Gaudin.
**
** Torrentlibre is free software; you can redistribute
** it and/or modify it under the terms of the GNU
** Library General Public License as published by the
** Free Software Foundation; either version 2, or (at
** your option) any later version.
**
********************************************************/

#include "qalfcrypto.h"
#include <QtDebug>

QalfCrypto::QalfCrypto() {
	gpgme_error_t result = gpgme_new(&context) ;
	Q_ASSERT(result == GPG_ERR_NO_ERROR) ;
	result = gpgme_set_protocol(context,GPGME_PROTOCOL_OpenPGP) ;
	Q_ASSERT(result == GPG_ERR_NO_ERROR) ;
	gpgme_set_armor(context,1) ;
	gpgme_set_textmode(context,1) ;
}

QalfCrypto::~QalfCrypto() {
	gpgme_release(context) ;
}

QString QalfCrypto::generateKeyPair(QString &username, QString &email,QString &passphrase) {
	gpgme_error_t result = gpgme_op_genkey(context,getKeyParams(username,email,passphrase).toUtf8(),NULL,NULL) ;
	Q_ASSERT(result == GPG_ERR_NO_ERROR) ;
	gpgme_genkey_result_t keys = gpgme_op_genkey_result(context) ;
	return QString(keys->fpr) ;
	
	
// 	gpgme_data_t keydata ;
// 	result = gpgme_data_new(&keydata) ;
// 	Q_ASSERT(result == GPG_ERR_NO_ERROR) ;
// 	result = gpgme_op_export(context,NULL,0,keydata) ;
// 	Q_ASSERT(result == GPG_ERR_NO_ERROR) ;
// 	
// 	int total = 0;
// 	int length = 1024 ;
// 	char buffer[length] ;
// 	char * keyBuffer = NULL ;
// 	ssize_t read ;
// 	read = gpgme_data_read(keydata,buffer,length) ;
// 	qDebug() << "read =" << read ;
// 	while(read != 0) {
// 		keyBuffer = (char*) realloc(keyBuffer,sizeof(char)*(total+read)) ;
// 		memcpy(buffer,keyBuffer+(sizeof(char)*total),read) ;
// 		total += read ;
// 		read = gpgme_data_read(keydata,&buffer,length) ;
// 	}
// 	keyBuffer = (char*) realloc(keyBuffer,sizeof(char)*(total+length)) ;
// 	memcpy(buffer,keyBuffer+(sizeof(char)*total),length) ;
// 	
// 	QString pubKey(keyBuffer) ;
// 	delete(keyBuffer) ;

	// getting private key
// 	result = gpgme_op_keylist_start(context,NULL,1) ;
// 	Q_ASSERT(result == GPG_ERR_NO_ERROR) ;
// 	gpgme_key_t key ;
// 	result = gpgme_op_keylist_next(context,&key) ;
// 	Q_ASSERT(result == GPG_ERR_NO_ERROR) ;
// 	qDebug() << "can sign" << key->can_sign ;
// 	gpgme_subkey_t subkey = key->subkeys ;
// 	qDebug() << "secret" << subkey->secret ;
// 	qDebug() << "can sign" << subkey->can_sign ;
// 	qDebug() << "keyid" << subkey->keyid ;
// 	qDebug() << "fpr" << subkey->fpr ;
// 	subkey = subkey->next ;
// 	qDebug() << "secret" << subkey->secret ;
// 	qDebug() << "can sign" << subkey->can_sign ;
// 	qDebug() << "keyid" << subkey->keyid ;
// 	qDebug() << "fpr" << subkey->fpr ;
}

bool QalfCrypto::checkKeyAuthorization(QString &key) {
	return false ;
}

QString QalfCrypto::getKeyParams(QString &username, QString &email,QString &passphrase) {
	QString param = QString("<GnupgKeyParms format=\"internal\">\n"
								"Key-Type: DSA\n"
								"Key-Length: 1024\n"
								"Subkey-Type: ELG-E\n"
								"Subkey-Length: 1024\n"
								"Name-Real: %1\n"
								"Name-Comment: generated by torrentlibre\n"
								"Name-Email: %2\n"
								"Expire-Date: 0\n"
								"Passphrase: %3\n"
								"</GnupgKeyParms>").arg(username).arg(email).arg(passphrase) ;
	return param ;
}
